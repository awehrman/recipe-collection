type User {
  id: ID! @unique
  name: String!
}

# TODO should name, plural and each individual altNames be flagged as @unique?

type Ingredient {
	id: ID! @unique
	parent: Ingredient @relation(name: "ParentIngredient")
	name: String! @unique
	plural: String @unique
	properties: Property! @relation(name: "Properties" onDelete: CASCADE)
	# TODO switch alternateNames to pull a type of AlternateName
	# since we can't filter on a list of scalar strings
	alternateNames: [ AlternateName! ]! @relation(name: "AlternateIngredientNames" onDelete: CASCADE)
	relatedIngredients: [ Ingredient! ]! @relation(name: "RelatedIngredients")
	substitutes: [ Ingredient! ]! @relation(name: "SubstituteIngredients")
	references: [ RecipeIngredient! ]! @relation(name: "RecipeReference")
	isValidated: Boolean! @default(value: "false")
	# if this ingredient is something that could in and of itself be considered a recipe
	# then we'll flag this as recipe searchable
 	isComposedIngredient: Boolean! @default(value: "false")
}

type AlternateName {
	id: ID! @unique
	name: String! @unique
}

type Property {
	id: ID! @unique
	meat: Boolean! @default(value: "false")
	poultry: Boolean! @default(value: "false")
	fish: Boolean! @default(value: "false")
	dairy: Boolean! @default(value: "false")
	soy: Boolean! @default(value: "false")
	gluten: Boolean! @default(value: "false")
}

type Recipe {
	id: ID! @unique
	evernoteGUID: String
	title: String!
	source: String
	image: String
	categories: [ Category! ]! @relation(name: "RecipeCategories")
	tags: [ Tag! ]! @relation(name: "RecipeTags")
	ingredients: [ RecipeIngredient! ]! @relation(name: "RecipeIngredients" onDelete: CASCADE)
	instructions: [ RecipeInstruction! ]! @relation(name: "RecipeInstructions" onDelete: CASCADE)
}

type Category {
	id: ID! @unique
	evernoteGUID: String
	name: String! @unique
}

type Tag {
	id: ID! @unique
	evernoteGUID: String
	name: String! @unique
}

type RecipeIngredient {
	id: ID! @unique
	blockIndex: Int!
	lineIndex: Int!
	reference: String!
	isParsed: Boolean! @default(value: "false")
	parsed: [ ParsedSegment! ]
}

type RecipeInstruction {
	id: ID! @unique
	blockIndex: Int!
	reference: String!
}

type ParsedSegment {
	id: ID! @unique
	rule: String!
	type: String!
	value: String!
	ingredient: Ingredient
}

type Container {
	id: ID! @unique
	currentIngredientID: ID
	isCardEnabled: Boolean! @default(value: "false")
	isContainerExpanded: Boolean! @default(value: "true")
	ingredients: [ Ingredient ]!
	label: String!
}

type IngredientAggregate {
	ingredientsCount: Int!
	newIngredientsCount: Int!
}