type AggregateAlternateName {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateIngredient {
  count: Int!
}

type AggregateIngredientAggregate {
  count: Int!
}

type AggregateParsedSegment {
  count: Int!
}

type AggregateProperties {
  count: Int!
}

type AggregateRecipe {
  count: Int!
}

type AggregateRecipeAggregate {
  count: Int!
}

type AggregateRecipeIngredient {
  count: Int!
}

type AggregateRecipeInstruction {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AlternateName {
  id: ID!
  name: String!
}

type AlternateNameConnection {
  pageInfo: PageInfo!
  edges: [AlternateNameEdge]!
  aggregate: AggregateAlternateName!
}

input AlternateNameCreateInput {
  id: ID
  name: String!
}

input AlternateNameCreateManyInput {
  create: [AlternateNameCreateInput!]
  connect: [AlternateNameWhereUniqueInput!]
}

type AlternateNameEdge {
  node: AlternateName!
  cursor: String!
}

enum AlternateNameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type AlternateNamePreviousValues {
  id: ID!
  name: String!
}

input AlternateNameScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [AlternateNameScalarWhereInput!]
  OR: [AlternateNameScalarWhereInput!]
  NOT: [AlternateNameScalarWhereInput!]
}

type AlternateNameSubscriptionPayload {
  mutation: MutationType!
  node: AlternateName
  updatedFields: [String!]
  previousValues: AlternateNamePreviousValues
}

input AlternateNameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AlternateNameWhereInput
  AND: [AlternateNameSubscriptionWhereInput!]
  OR: [AlternateNameSubscriptionWhereInput!]
  NOT: [AlternateNameSubscriptionWhereInput!]
}

input AlternateNameUpdateDataInput {
  name: String
}

input AlternateNameUpdateInput {
  name: String
}

input AlternateNameUpdateManyDataInput {
  name: String
}

input AlternateNameUpdateManyInput {
  create: [AlternateNameCreateInput!]
  update: [AlternateNameUpdateWithWhereUniqueNestedInput!]
  upsert: [AlternateNameUpsertWithWhereUniqueNestedInput!]
  delete: [AlternateNameWhereUniqueInput!]
  connect: [AlternateNameWhereUniqueInput!]
  set: [AlternateNameWhereUniqueInput!]
  disconnect: [AlternateNameWhereUniqueInput!]
  deleteMany: [AlternateNameScalarWhereInput!]
  updateMany: [AlternateNameUpdateManyWithWhereNestedInput!]
}

input AlternateNameUpdateManyMutationInput {
  name: String
}

input AlternateNameUpdateManyWithWhereNestedInput {
  where: AlternateNameScalarWhereInput!
  data: AlternateNameUpdateManyDataInput!
}

input AlternateNameUpdateWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput!
  data: AlternateNameUpdateDataInput!
}

input AlternateNameUpsertWithWhereUniqueNestedInput {
  where: AlternateNameWhereUniqueInput!
  update: AlternateNameUpdateDataInput!
  create: AlternateNameCreateInput!
}

input AlternateNameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [AlternateNameWhereInput!]
  OR: [AlternateNameWhereInput!]
  NOT: [AlternateNameWhereInput!]
}

input AlternateNameWhereUniqueInput {
  id: ID
  name: String
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  evernoteGUID: String
  name: String!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  evernoteGUID: String
  name: String!
}

input CategoryCreateManyInput {
  create: [CategoryCreateInput!]
  connect: [CategoryWhereUniqueInput!]
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  evernoteGUID_ASC
  evernoteGUID_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  evernoteGUID: String
  name: String!
}

input CategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  evernoteGUID: String
  evernoteGUID_not: String
  evernoteGUID_in: [String!]
  evernoteGUID_not_in: [String!]
  evernoteGUID_lt: String
  evernoteGUID_lte: String
  evernoteGUID_gt: String
  evernoteGUID_gte: String
  evernoteGUID_contains: String
  evernoteGUID_not_contains: String
  evernoteGUID_starts_with: String
  evernoteGUID_not_starts_with: String
  evernoteGUID_ends_with: String
  evernoteGUID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  evernoteGUID: String
  name: String
}

input CategoryUpdateInput {
  evernoteGUID: String
  name: String
}

input CategoryUpdateManyDataInput {
  evernoteGUID: String
  name: String
}

input CategoryUpdateManyInput {
  create: [CategoryCreateInput!]
  update: [CategoryUpdateWithWhereUniqueNestedInput!]
  upsert: [CategoryUpsertWithWhereUniqueNestedInput!]
  delete: [CategoryWhereUniqueInput!]
  connect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
}

input CategoryUpdateManyMutationInput {
  evernoteGUID: String
  name: String
}

input CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput!
  data: CategoryUpdateManyDataInput!
}

input CategoryUpdateWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateDataInput!
}

input CategoryUpsertWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  evernoteGUID: String
  evernoteGUID_not: String
  evernoteGUID_in: [String!]
  evernoteGUID_not_in: [String!]
  evernoteGUID_lt: String
  evernoteGUID_lte: String
  evernoteGUID_gt: String
  evernoteGUID_gte: String
  evernoteGUID_contains: String
  evernoteGUID_not_contains: String
  evernoteGUID_starts_with: String
  evernoteGUID_not_starts_with: String
  evernoteGUID_ends_with: String
  evernoteGUID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  name: String
}

type Ingredient {
  id: ID!
  name: String!
  plural: String
  alternateNames(where: AlternateNameWhereInput, orderBy: AlternateNameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AlternateName!]
  properties: Properties!
  isComposedIngredient: Boolean!
  isValidated: Boolean!
  parent: Ingredient
  relatedIngredients(where: IngredientWhereInput, orderBy: IngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ingredient!]
  substitutes(where: IngredientWhereInput, orderBy: IngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ingredient!]
  references(where: RecipeIngredientWhereInput, orderBy: RecipeIngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeIngredient!]
}

type IngredientAggregate {
  id: ID!
  ingredientsCount: Int!
  newIngredientsCount: Int!
}

type IngredientAggregateConnection {
  pageInfo: PageInfo!
  edges: [IngredientAggregateEdge]!
  aggregate: AggregateIngredientAggregate!
}

input IngredientAggregateCreateInput {
  id: ID
  ingredientsCount: Int!
  newIngredientsCount: Int!
}

type IngredientAggregateEdge {
  node: IngredientAggregate!
  cursor: String!
}

enum IngredientAggregateOrderByInput {
  id_ASC
  id_DESC
  ingredientsCount_ASC
  ingredientsCount_DESC
  newIngredientsCount_ASC
  newIngredientsCount_DESC
}

type IngredientAggregatePreviousValues {
  id: ID!
  ingredientsCount: Int!
  newIngredientsCount: Int!
}

type IngredientAggregateSubscriptionPayload {
  mutation: MutationType!
  node: IngredientAggregate
  updatedFields: [String!]
  previousValues: IngredientAggregatePreviousValues
}

input IngredientAggregateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IngredientAggregateWhereInput
  AND: [IngredientAggregateSubscriptionWhereInput!]
  OR: [IngredientAggregateSubscriptionWhereInput!]
  NOT: [IngredientAggregateSubscriptionWhereInput!]
}

input IngredientAggregateUpdateInput {
  ingredientsCount: Int
  newIngredientsCount: Int
}

input IngredientAggregateUpdateManyMutationInput {
  ingredientsCount: Int
  newIngredientsCount: Int
}

input IngredientAggregateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ingredientsCount: Int
  ingredientsCount_not: Int
  ingredientsCount_in: [Int!]
  ingredientsCount_not_in: [Int!]
  ingredientsCount_lt: Int
  ingredientsCount_lte: Int
  ingredientsCount_gt: Int
  ingredientsCount_gte: Int
  newIngredientsCount: Int
  newIngredientsCount_not: Int
  newIngredientsCount_in: [Int!]
  newIngredientsCount_not_in: [Int!]
  newIngredientsCount_lt: Int
  newIngredientsCount_lte: Int
  newIngredientsCount_gt: Int
  newIngredientsCount_gte: Int
  AND: [IngredientAggregateWhereInput!]
  OR: [IngredientAggregateWhereInput!]
  NOT: [IngredientAggregateWhereInput!]
}

input IngredientAggregateWhereUniqueInput {
  id: ID
}

type IngredientConnection {
  pageInfo: PageInfo!
  edges: [IngredientEdge]!
  aggregate: AggregateIngredient!
}

input IngredientCreateInput {
  id: ID
  name: String!
  plural: String
  alternateNames: AlternateNameCreateManyInput
  properties: PropertiesCreateOneInput!
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientCreateOneWithoutParentInput
  relatedIngredients: IngredientCreateManyWithoutRelatedIngredientsInput
  substitutes: IngredientCreateManyWithoutSubstitutesInput
  references: RecipeIngredientCreateManyInput
}

input IngredientCreateManyWithoutRelatedIngredientsInput {
  create: [IngredientCreateWithoutRelatedIngredientsInput!]
  connect: [IngredientWhereUniqueInput!]
}

input IngredientCreateManyWithoutSubstitutesInput {
  create: [IngredientCreateWithoutSubstitutesInput!]
  connect: [IngredientWhereUniqueInput!]
}

input IngredientCreateOneInput {
  create: IngredientCreateInput
  connect: IngredientWhereUniqueInput
}

input IngredientCreateOneWithoutParentInput {
  create: IngredientCreateWithoutParentInput
  connect: IngredientWhereUniqueInput
}

input IngredientCreateWithoutParentInput {
  id: ID
  name: String!
  plural: String
  alternateNames: AlternateNameCreateManyInput
  properties: PropertiesCreateOneInput!
  isComposedIngredient: Boolean
  isValidated: Boolean
  relatedIngredients: IngredientCreateManyWithoutRelatedIngredientsInput
  substitutes: IngredientCreateManyWithoutSubstitutesInput
  references: RecipeIngredientCreateManyInput
}

input IngredientCreateWithoutRelatedIngredientsInput {
  id: ID
  name: String!
  plural: String
  alternateNames: AlternateNameCreateManyInput
  properties: PropertiesCreateOneInput!
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientCreateOneWithoutParentInput
  substitutes: IngredientCreateManyWithoutSubstitutesInput
  references: RecipeIngredientCreateManyInput
}

input IngredientCreateWithoutSubstitutesInput {
  id: ID
  name: String!
  plural: String
  alternateNames: AlternateNameCreateManyInput
  properties: PropertiesCreateOneInput!
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientCreateOneWithoutParentInput
  relatedIngredients: IngredientCreateManyWithoutRelatedIngredientsInput
  references: RecipeIngredientCreateManyInput
}

type IngredientEdge {
  node: Ingredient!
  cursor: String!
}

enum IngredientOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  plural_ASC
  plural_DESC
  isComposedIngredient_ASC
  isComposedIngredient_DESC
  isValidated_ASC
  isValidated_DESC
}

type IngredientPreviousValues {
  id: ID!
  name: String!
  plural: String
  isComposedIngredient: Boolean!
  isValidated: Boolean!
}

input IngredientScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  plural: String
  plural_not: String
  plural_in: [String!]
  plural_not_in: [String!]
  plural_lt: String
  plural_lte: String
  plural_gt: String
  plural_gte: String
  plural_contains: String
  plural_not_contains: String
  plural_starts_with: String
  plural_not_starts_with: String
  plural_ends_with: String
  plural_not_ends_with: String
  isComposedIngredient: Boolean
  isComposedIngredient_not: Boolean
  isValidated: Boolean
  isValidated_not: Boolean
  AND: [IngredientScalarWhereInput!]
  OR: [IngredientScalarWhereInput!]
  NOT: [IngredientScalarWhereInput!]
}

type IngredientSubscriptionPayload {
  mutation: MutationType!
  node: Ingredient
  updatedFields: [String!]
  previousValues: IngredientPreviousValues
}

input IngredientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IngredientWhereInput
  AND: [IngredientSubscriptionWhereInput!]
  OR: [IngredientSubscriptionWhereInput!]
  NOT: [IngredientSubscriptionWhereInput!]
}

input IngredientUpdateDataInput {
  name: String
  plural: String
  alternateNames: AlternateNameUpdateManyInput
  properties: PropertiesUpdateOneRequiredInput
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientUpdateOneWithoutParentInput
  relatedIngredients: IngredientUpdateManyWithoutRelatedIngredientsInput
  substitutes: IngredientUpdateManyWithoutSubstitutesInput
  references: RecipeIngredientUpdateManyInput
}

input IngredientUpdateInput {
  name: String
  plural: String
  alternateNames: AlternateNameUpdateManyInput
  properties: PropertiesUpdateOneRequiredInput
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientUpdateOneWithoutParentInput
  relatedIngredients: IngredientUpdateManyWithoutRelatedIngredientsInput
  substitutes: IngredientUpdateManyWithoutSubstitutesInput
  references: RecipeIngredientUpdateManyInput
}

input IngredientUpdateManyDataInput {
  name: String
  plural: String
  isComposedIngredient: Boolean
  isValidated: Boolean
}

input IngredientUpdateManyMutationInput {
  name: String
  plural: String
  isComposedIngredient: Boolean
  isValidated: Boolean
}

input IngredientUpdateManyWithoutRelatedIngredientsInput {
  create: [IngredientCreateWithoutRelatedIngredientsInput!]
  delete: [IngredientWhereUniqueInput!]
  connect: [IngredientWhereUniqueInput!]
  set: [IngredientWhereUniqueInput!]
  disconnect: [IngredientWhereUniqueInput!]
  update: [IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput!]
  upsert: [IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput!]
  deleteMany: [IngredientScalarWhereInput!]
  updateMany: [IngredientUpdateManyWithWhereNestedInput!]
}

input IngredientUpdateManyWithoutSubstitutesInput {
  create: [IngredientCreateWithoutSubstitutesInput!]
  delete: [IngredientWhereUniqueInput!]
  connect: [IngredientWhereUniqueInput!]
  set: [IngredientWhereUniqueInput!]
  disconnect: [IngredientWhereUniqueInput!]
  update: [IngredientUpdateWithWhereUniqueWithoutSubstitutesInput!]
  upsert: [IngredientUpsertWithWhereUniqueWithoutSubstitutesInput!]
  deleteMany: [IngredientScalarWhereInput!]
  updateMany: [IngredientUpdateManyWithWhereNestedInput!]
}

input IngredientUpdateManyWithWhereNestedInput {
  where: IngredientScalarWhereInput!
  data: IngredientUpdateManyDataInput!
}

input IngredientUpdateOneInput {
  create: IngredientCreateInput
  update: IngredientUpdateDataInput
  upsert: IngredientUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: IngredientWhereUniqueInput
}

input IngredientUpdateOneWithoutParentInput {
  create: IngredientCreateWithoutParentInput
  update: IngredientUpdateWithoutParentDataInput
  upsert: IngredientUpsertWithoutParentInput
  delete: Boolean
  disconnect: Boolean
  connect: IngredientWhereUniqueInput
}

input IngredientUpdateWithoutParentDataInput {
  name: String
  plural: String
  alternateNames: AlternateNameUpdateManyInput
  properties: PropertiesUpdateOneRequiredInput
  isComposedIngredient: Boolean
  isValidated: Boolean
  relatedIngredients: IngredientUpdateManyWithoutRelatedIngredientsInput
  substitutes: IngredientUpdateManyWithoutSubstitutesInput
  references: RecipeIngredientUpdateManyInput
}

input IngredientUpdateWithoutRelatedIngredientsDataInput {
  name: String
  plural: String
  alternateNames: AlternateNameUpdateManyInput
  properties: PropertiesUpdateOneRequiredInput
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientUpdateOneWithoutParentInput
  substitutes: IngredientUpdateManyWithoutSubstitutesInput
  references: RecipeIngredientUpdateManyInput
}

input IngredientUpdateWithoutSubstitutesDataInput {
  name: String
  plural: String
  alternateNames: AlternateNameUpdateManyInput
  properties: PropertiesUpdateOneRequiredInput
  isComposedIngredient: Boolean
  isValidated: Boolean
  parent: IngredientUpdateOneWithoutParentInput
  relatedIngredients: IngredientUpdateManyWithoutRelatedIngredientsInput
  references: RecipeIngredientUpdateManyInput
}

input IngredientUpdateWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput!
  data: IngredientUpdateWithoutRelatedIngredientsDataInput!
}

input IngredientUpdateWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput!
  data: IngredientUpdateWithoutSubstitutesDataInput!
}

input IngredientUpsertNestedInput {
  update: IngredientUpdateDataInput!
  create: IngredientCreateInput!
}

input IngredientUpsertWithoutParentInput {
  update: IngredientUpdateWithoutParentDataInput!
  create: IngredientCreateWithoutParentInput!
}

input IngredientUpsertWithWhereUniqueWithoutRelatedIngredientsInput {
  where: IngredientWhereUniqueInput!
  update: IngredientUpdateWithoutRelatedIngredientsDataInput!
  create: IngredientCreateWithoutRelatedIngredientsInput!
}

input IngredientUpsertWithWhereUniqueWithoutSubstitutesInput {
  where: IngredientWhereUniqueInput!
  update: IngredientUpdateWithoutSubstitutesDataInput!
  create: IngredientCreateWithoutSubstitutesInput!
}

input IngredientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  plural: String
  plural_not: String
  plural_in: [String!]
  plural_not_in: [String!]
  plural_lt: String
  plural_lte: String
  plural_gt: String
  plural_gte: String
  plural_contains: String
  plural_not_contains: String
  plural_starts_with: String
  plural_not_starts_with: String
  plural_ends_with: String
  plural_not_ends_with: String
  alternateNames_every: AlternateNameWhereInput
  alternateNames_some: AlternateNameWhereInput
  alternateNames_none: AlternateNameWhereInput
  properties: PropertiesWhereInput
  isComposedIngredient: Boolean
  isComposedIngredient_not: Boolean
  isValidated: Boolean
  isValidated_not: Boolean
  parent: IngredientWhereInput
  relatedIngredients_every: IngredientWhereInput
  relatedIngredients_some: IngredientWhereInput
  relatedIngredients_none: IngredientWhereInput
  substitutes_every: IngredientWhereInput
  substitutes_some: IngredientWhereInput
  substitutes_none: IngredientWhereInput
  references_every: RecipeIngredientWhereInput
  references_some: RecipeIngredientWhereInput
  references_none: RecipeIngredientWhereInput
  AND: [IngredientWhereInput!]
  OR: [IngredientWhereInput!]
  NOT: [IngredientWhereInput!]
}

input IngredientWhereUniqueInput {
  id: ID
  name: String
  plural: String
}

scalar Long

type Mutation {
  createAlternateName(data: AlternateNameCreateInput!): AlternateName!
  updateAlternateName(data: AlternateNameUpdateInput!, where: AlternateNameWhereUniqueInput!): AlternateName
  updateManyAlternateNames(data: AlternateNameUpdateManyMutationInput!, where: AlternateNameWhereInput): BatchPayload!
  upsertAlternateName(where: AlternateNameWhereUniqueInput!, create: AlternateNameCreateInput!, update: AlternateNameUpdateInput!): AlternateName!
  deleteAlternateName(where: AlternateNameWhereUniqueInput!): AlternateName
  deleteManyAlternateNames(where: AlternateNameWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createIngredient(data: IngredientCreateInput!): Ingredient!
  updateIngredient(data: IngredientUpdateInput!, where: IngredientWhereUniqueInput!): Ingredient
  updateManyIngredients(data: IngredientUpdateManyMutationInput!, where: IngredientWhereInput): BatchPayload!
  upsertIngredient(where: IngredientWhereUniqueInput!, create: IngredientCreateInput!, update: IngredientUpdateInput!): Ingredient!
  deleteIngredient(where: IngredientWhereUniqueInput!): Ingredient
  deleteManyIngredients(where: IngredientWhereInput): BatchPayload!
  createIngredientAggregate(data: IngredientAggregateCreateInput!): IngredientAggregate!
  updateIngredientAggregate(data: IngredientAggregateUpdateInput!, where: IngredientAggregateWhereUniqueInput!): IngredientAggregate
  updateManyIngredientAggregates(data: IngredientAggregateUpdateManyMutationInput!, where: IngredientAggregateWhereInput): BatchPayload!
  upsertIngredientAggregate(where: IngredientAggregateWhereUniqueInput!, create: IngredientAggregateCreateInput!, update: IngredientAggregateUpdateInput!): IngredientAggregate!
  deleteIngredientAggregate(where: IngredientAggregateWhereUniqueInput!): IngredientAggregate
  deleteManyIngredientAggregates(where: IngredientAggregateWhereInput): BatchPayload!
  createParsedSegment(data: ParsedSegmentCreateInput!): ParsedSegment!
  updateParsedSegment(data: ParsedSegmentUpdateInput!, where: ParsedSegmentWhereUniqueInput!): ParsedSegment
  updateManyParsedSegments(data: ParsedSegmentUpdateManyMutationInput!, where: ParsedSegmentWhereInput): BatchPayload!
  upsertParsedSegment(where: ParsedSegmentWhereUniqueInput!, create: ParsedSegmentCreateInput!, update: ParsedSegmentUpdateInput!): ParsedSegment!
  deleteParsedSegment(where: ParsedSegmentWhereUniqueInput!): ParsedSegment
  deleteManyParsedSegments(where: ParsedSegmentWhereInput): BatchPayload!
  createProperties(data: PropertiesCreateInput!): Properties!
  updateProperties(data: PropertiesUpdateInput!, where: PropertiesWhereUniqueInput!): Properties
  updateManyPropertieses(data: PropertiesUpdateManyMutationInput!, where: PropertiesWhereInput): BatchPayload!
  upsertProperties(where: PropertiesWhereUniqueInput!, create: PropertiesCreateInput!, update: PropertiesUpdateInput!): Properties!
  deleteProperties(where: PropertiesWhereUniqueInput!): Properties
  deleteManyPropertieses(where: PropertiesWhereInput): BatchPayload!
  createRecipe(data: RecipeCreateInput!): Recipe!
  updateRecipe(data: RecipeUpdateInput!, where: RecipeWhereUniqueInput!): Recipe
  updateManyRecipes(data: RecipeUpdateManyMutationInput!, where: RecipeWhereInput): BatchPayload!
  upsertRecipe(where: RecipeWhereUniqueInput!, create: RecipeCreateInput!, update: RecipeUpdateInput!): Recipe!
  deleteRecipe(where: RecipeWhereUniqueInput!): Recipe
  deleteManyRecipes(where: RecipeWhereInput): BatchPayload!
  createRecipeAggregate(data: RecipeAggregateCreateInput!): RecipeAggregate!
  updateRecipeAggregate(data: RecipeAggregateUpdateInput!, where: RecipeAggregateWhereUniqueInput!): RecipeAggregate
  updateManyRecipeAggregates(data: RecipeAggregateUpdateManyMutationInput!, where: RecipeAggregateWhereInput): BatchPayload!
  upsertRecipeAggregate(where: RecipeAggregateWhereUniqueInput!, create: RecipeAggregateCreateInput!, update: RecipeAggregateUpdateInput!): RecipeAggregate!
  deleteRecipeAggregate(where: RecipeAggregateWhereUniqueInput!): RecipeAggregate
  deleteManyRecipeAggregates(where: RecipeAggregateWhereInput): BatchPayload!
  createRecipeIngredient(data: RecipeIngredientCreateInput!): RecipeIngredient!
  updateRecipeIngredient(data: RecipeIngredientUpdateInput!, where: RecipeIngredientWhereUniqueInput!): RecipeIngredient
  updateManyRecipeIngredients(data: RecipeIngredientUpdateManyMutationInput!, where: RecipeIngredientWhereInput): BatchPayload!
  upsertRecipeIngredient(where: RecipeIngredientWhereUniqueInput!, create: RecipeIngredientCreateInput!, update: RecipeIngredientUpdateInput!): RecipeIngredient!
  deleteRecipeIngredient(where: RecipeIngredientWhereUniqueInput!): RecipeIngredient
  deleteManyRecipeIngredients(where: RecipeIngredientWhereInput): BatchPayload!
  createRecipeInstruction(data: RecipeInstructionCreateInput!): RecipeInstruction!
  updateRecipeInstruction(data: RecipeInstructionUpdateInput!, where: RecipeInstructionWhereUniqueInput!): RecipeInstruction
  updateManyRecipeInstructions(data: RecipeInstructionUpdateManyMutationInput!, where: RecipeInstructionWhereInput): BatchPayload!
  upsertRecipeInstruction(where: RecipeInstructionWhereUniqueInput!, create: RecipeInstructionCreateInput!, update: RecipeInstructionUpdateInput!): RecipeInstruction!
  deleteRecipeInstruction(where: RecipeInstructionWhereUniqueInput!): RecipeInstruction
  deleteManyRecipeInstructions(where: RecipeInstructionWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ParsedSegment {
  id: ID!
  rule: String!
  type: String!
  value: String!
  ingredient: Ingredient
}

type ParsedSegmentConnection {
  pageInfo: PageInfo!
  edges: [ParsedSegmentEdge]!
  aggregate: AggregateParsedSegment!
}

input ParsedSegmentCreateInput {
  id: ID
  rule: String!
  type: String!
  value: String!
  ingredient: IngredientCreateOneInput
}

input ParsedSegmentCreateManyInput {
  create: [ParsedSegmentCreateInput!]
  connect: [ParsedSegmentWhereUniqueInput!]
}

type ParsedSegmentEdge {
  node: ParsedSegment!
  cursor: String!
}

enum ParsedSegmentOrderByInput {
  id_ASC
  id_DESC
  rule_ASC
  rule_DESC
  type_ASC
  type_DESC
  value_ASC
  value_DESC
}

type ParsedSegmentPreviousValues {
  id: ID!
  rule: String!
  type: String!
  value: String!
}

input ParsedSegmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rule: String
  rule_not: String
  rule_in: [String!]
  rule_not_in: [String!]
  rule_lt: String
  rule_lte: String
  rule_gt: String
  rule_gte: String
  rule_contains: String
  rule_not_contains: String
  rule_starts_with: String
  rule_not_starts_with: String
  rule_ends_with: String
  rule_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [ParsedSegmentScalarWhereInput!]
  OR: [ParsedSegmentScalarWhereInput!]
  NOT: [ParsedSegmentScalarWhereInput!]
}

type ParsedSegmentSubscriptionPayload {
  mutation: MutationType!
  node: ParsedSegment
  updatedFields: [String!]
  previousValues: ParsedSegmentPreviousValues
}

input ParsedSegmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParsedSegmentWhereInput
  AND: [ParsedSegmentSubscriptionWhereInput!]
  OR: [ParsedSegmentSubscriptionWhereInput!]
  NOT: [ParsedSegmentSubscriptionWhereInput!]
}

input ParsedSegmentUpdateDataInput {
  rule: String
  type: String
  value: String
  ingredient: IngredientUpdateOneInput
}

input ParsedSegmentUpdateInput {
  rule: String
  type: String
  value: String
  ingredient: IngredientUpdateOneInput
}

input ParsedSegmentUpdateManyDataInput {
  rule: String
  type: String
  value: String
}

input ParsedSegmentUpdateManyInput {
  create: [ParsedSegmentCreateInput!]
  update: [ParsedSegmentUpdateWithWhereUniqueNestedInput!]
  upsert: [ParsedSegmentUpsertWithWhereUniqueNestedInput!]
  delete: [ParsedSegmentWhereUniqueInput!]
  connect: [ParsedSegmentWhereUniqueInput!]
  set: [ParsedSegmentWhereUniqueInput!]
  disconnect: [ParsedSegmentWhereUniqueInput!]
  deleteMany: [ParsedSegmentScalarWhereInput!]
  updateMany: [ParsedSegmentUpdateManyWithWhereNestedInput!]
}

input ParsedSegmentUpdateManyMutationInput {
  rule: String
  type: String
  value: String
}

input ParsedSegmentUpdateManyWithWhereNestedInput {
  where: ParsedSegmentScalarWhereInput!
  data: ParsedSegmentUpdateManyDataInput!
}

input ParsedSegmentUpdateWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput!
  data: ParsedSegmentUpdateDataInput!
}

input ParsedSegmentUpsertWithWhereUniqueNestedInput {
  where: ParsedSegmentWhereUniqueInput!
  update: ParsedSegmentUpdateDataInput!
  create: ParsedSegmentCreateInput!
}

input ParsedSegmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rule: String
  rule_not: String
  rule_in: [String!]
  rule_not_in: [String!]
  rule_lt: String
  rule_lte: String
  rule_gt: String
  rule_gte: String
  rule_contains: String
  rule_not_contains: String
  rule_starts_with: String
  rule_not_starts_with: String
  rule_ends_with: String
  rule_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  ingredient: IngredientWhereInput
  AND: [ParsedSegmentWhereInput!]
  OR: [ParsedSegmentWhereInput!]
  NOT: [ParsedSegmentWhereInput!]
}

input ParsedSegmentWhereUniqueInput {
  id: ID
}

type Properties {
  id: ID!
  meat: Boolean!
  poultry: Boolean!
  fish: Boolean!
  dairy: Boolean!
  soy: Boolean!
  gluten: Boolean!
}

type PropertiesConnection {
  pageInfo: PageInfo!
  edges: [PropertiesEdge]!
  aggregate: AggregateProperties!
}

input PropertiesCreateInput {
  id: ID
  meat: Boolean
  poultry: Boolean
  fish: Boolean
  dairy: Boolean
  soy: Boolean
  gluten: Boolean
}

input PropertiesCreateOneInput {
  create: PropertiesCreateInput
  connect: PropertiesWhereUniqueInput
}

type PropertiesEdge {
  node: Properties!
  cursor: String!
}

enum PropertiesOrderByInput {
  id_ASC
  id_DESC
  meat_ASC
  meat_DESC
  poultry_ASC
  poultry_DESC
  fish_ASC
  fish_DESC
  dairy_ASC
  dairy_DESC
  soy_ASC
  soy_DESC
  gluten_ASC
  gluten_DESC
}

type PropertiesPreviousValues {
  id: ID!
  meat: Boolean!
  poultry: Boolean!
  fish: Boolean!
  dairy: Boolean!
  soy: Boolean!
  gluten: Boolean!
}

type PropertiesSubscriptionPayload {
  mutation: MutationType!
  node: Properties
  updatedFields: [String!]
  previousValues: PropertiesPreviousValues
}

input PropertiesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PropertiesWhereInput
  AND: [PropertiesSubscriptionWhereInput!]
  OR: [PropertiesSubscriptionWhereInput!]
  NOT: [PropertiesSubscriptionWhereInput!]
}

input PropertiesUpdateDataInput {
  meat: Boolean
  poultry: Boolean
  fish: Boolean
  dairy: Boolean
  soy: Boolean
  gluten: Boolean
}

input PropertiesUpdateInput {
  meat: Boolean
  poultry: Boolean
  fish: Boolean
  dairy: Boolean
  soy: Boolean
  gluten: Boolean
}

input PropertiesUpdateManyMutationInput {
  meat: Boolean
  poultry: Boolean
  fish: Boolean
  dairy: Boolean
  soy: Boolean
  gluten: Boolean
}

input PropertiesUpdateOneRequiredInput {
  create: PropertiesCreateInput
  update: PropertiesUpdateDataInput
  upsert: PropertiesUpsertNestedInput
  connect: PropertiesWhereUniqueInput
}

input PropertiesUpsertNestedInput {
  update: PropertiesUpdateDataInput!
  create: PropertiesCreateInput!
}

input PropertiesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  meat: Boolean
  meat_not: Boolean
  poultry: Boolean
  poultry_not: Boolean
  fish: Boolean
  fish_not: Boolean
  dairy: Boolean
  dairy_not: Boolean
  soy: Boolean
  soy_not: Boolean
  gluten: Boolean
  gluten_not: Boolean
  AND: [PropertiesWhereInput!]
  OR: [PropertiesWhereInput!]
  NOT: [PropertiesWhereInput!]
}

input PropertiesWhereUniqueInput {
  id: ID
}

type Query {
  alternateName(where: AlternateNameWhereUniqueInput!): AlternateName
  alternateNames(where: AlternateNameWhereInput, orderBy: AlternateNameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AlternateName]!
  alternateNamesConnection(where: AlternateNameWhereInput, orderBy: AlternateNameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AlternateNameConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  ingredient(where: IngredientWhereUniqueInput!): Ingredient
  ingredients(where: IngredientWhereInput, orderBy: IngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ingredient]!
  ingredientsConnection(where: IngredientWhereInput, orderBy: IngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IngredientConnection!
  ingredientAggregate(where: IngredientAggregateWhereUniqueInput!): IngredientAggregate
  ingredientAggregates(where: IngredientAggregateWhereInput, orderBy: IngredientAggregateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IngredientAggregate]!
  ingredientAggregatesConnection(where: IngredientAggregateWhereInput, orderBy: IngredientAggregateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IngredientAggregateConnection!
  parsedSegment(where: ParsedSegmentWhereUniqueInput!): ParsedSegment
  parsedSegments(where: ParsedSegmentWhereInput, orderBy: ParsedSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ParsedSegment]!
  parsedSegmentsConnection(where: ParsedSegmentWhereInput, orderBy: ParsedSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParsedSegmentConnection!
  properties(where: PropertiesWhereUniqueInput!): Properties
  propertieses(where: PropertiesWhereInput, orderBy: PropertiesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Properties]!
  propertiesesConnection(where: PropertiesWhereInput, orderBy: PropertiesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PropertiesConnection!
  recipe(where: RecipeWhereUniqueInput!): Recipe
  recipes(where: RecipeWhereInput, orderBy: RecipeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Recipe]!
  recipesConnection(where: RecipeWhereInput, orderBy: RecipeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecipeConnection!
  recipeAggregate(where: RecipeAggregateWhereUniqueInput!): RecipeAggregate
  recipeAggregates(where: RecipeAggregateWhereInput, orderBy: RecipeAggregateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeAggregate]!
  recipeAggregatesConnection(where: RecipeAggregateWhereInput, orderBy: RecipeAggregateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecipeAggregateConnection!
  recipeIngredient(where: RecipeIngredientWhereUniqueInput!): RecipeIngredient
  recipeIngredients(where: RecipeIngredientWhereInput, orderBy: RecipeIngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeIngredient]!
  recipeIngredientsConnection(where: RecipeIngredientWhereInput, orderBy: RecipeIngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecipeIngredientConnection!
  recipeInstruction(where: RecipeInstructionWhereUniqueInput!): RecipeInstruction
  recipeInstructions(where: RecipeInstructionWhereInput, orderBy: RecipeInstructionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeInstruction]!
  recipeInstructionsConnection(where: RecipeInstructionWhereInput, orderBy: RecipeInstructionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RecipeInstructionConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  node(id: ID!): Node
}

type Recipe {
  id: ID!
  evernoteGUID: String
  title: String!
  source: String
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  image: String
  ingredients(where: RecipeIngredientWhereInput, orderBy: RecipeIngredientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeIngredient!]
  instructions(where: RecipeInstructionWhereInput, orderBy: RecipeInstructionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RecipeInstruction!]
}

type RecipeAggregate {
  id: ID!
  recipesCount: Int!
}

type RecipeAggregateConnection {
  pageInfo: PageInfo!
  edges: [RecipeAggregateEdge]!
  aggregate: AggregateRecipeAggregate!
}

input RecipeAggregateCreateInput {
  id: ID
  recipesCount: Int!
}

type RecipeAggregateEdge {
  node: RecipeAggregate!
  cursor: String!
}

enum RecipeAggregateOrderByInput {
  id_ASC
  id_DESC
  recipesCount_ASC
  recipesCount_DESC
}

type RecipeAggregatePreviousValues {
  id: ID!
  recipesCount: Int!
}

type RecipeAggregateSubscriptionPayload {
  mutation: MutationType!
  node: RecipeAggregate
  updatedFields: [String!]
  previousValues: RecipeAggregatePreviousValues
}

input RecipeAggregateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecipeAggregateWhereInput
  AND: [RecipeAggregateSubscriptionWhereInput!]
  OR: [RecipeAggregateSubscriptionWhereInput!]
  NOT: [RecipeAggregateSubscriptionWhereInput!]
}

input RecipeAggregateUpdateInput {
  recipesCount: Int
}

input RecipeAggregateUpdateManyMutationInput {
  recipesCount: Int
}

input RecipeAggregateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  recipesCount: Int
  recipesCount_not: Int
  recipesCount_in: [Int!]
  recipesCount_not_in: [Int!]
  recipesCount_lt: Int
  recipesCount_lte: Int
  recipesCount_gt: Int
  recipesCount_gte: Int
  AND: [RecipeAggregateWhereInput!]
  OR: [RecipeAggregateWhereInput!]
  NOT: [RecipeAggregateWhereInput!]
}

input RecipeAggregateWhereUniqueInput {
  id: ID
}

type RecipeConnection {
  pageInfo: PageInfo!
  edges: [RecipeEdge]!
  aggregate: AggregateRecipe!
}

input RecipeCreateInput {
  id: ID
  evernoteGUID: String
  title: String!
  source: String
  categories: CategoryCreateManyInput
  tags: TagCreateManyInput
  image: String
  ingredients: RecipeIngredientCreateManyInput
  instructions: RecipeInstructionCreateManyInput
}

type RecipeEdge {
  node: Recipe!
  cursor: String!
}

type RecipeIngredient {
  id: ID!
  blockIndex: Int!
  lineIndex: Int!
  reference: String!
  rule: String
  isParsed: Boolean!
  parsed(where: ParsedSegmentWhereInput, orderBy: ParsedSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ParsedSegment!]
}

type RecipeIngredientConnection {
  pageInfo: PageInfo!
  edges: [RecipeIngredientEdge]!
  aggregate: AggregateRecipeIngredient!
}

input RecipeIngredientCreateInput {
  id: ID
  blockIndex: Int!
  lineIndex: Int!
  reference: String!
  rule: String
  isParsed: Boolean
  parsed: ParsedSegmentCreateManyInput
}

input RecipeIngredientCreateManyInput {
  create: [RecipeIngredientCreateInput!]
  connect: [RecipeIngredientWhereUniqueInput!]
}

type RecipeIngredientEdge {
  node: RecipeIngredient!
  cursor: String!
}

enum RecipeIngredientOrderByInput {
  id_ASC
  id_DESC
  blockIndex_ASC
  blockIndex_DESC
  lineIndex_ASC
  lineIndex_DESC
  reference_ASC
  reference_DESC
  rule_ASC
  rule_DESC
  isParsed_ASC
  isParsed_DESC
}

type RecipeIngredientPreviousValues {
  id: ID!
  blockIndex: Int!
  lineIndex: Int!
  reference: String!
  rule: String
  isParsed: Boolean!
}

input RecipeIngredientScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blockIndex: Int
  blockIndex_not: Int
  blockIndex_in: [Int!]
  blockIndex_not_in: [Int!]
  blockIndex_lt: Int
  blockIndex_lte: Int
  blockIndex_gt: Int
  blockIndex_gte: Int
  lineIndex: Int
  lineIndex_not: Int
  lineIndex_in: [Int!]
  lineIndex_not_in: [Int!]
  lineIndex_lt: Int
  lineIndex_lte: Int
  lineIndex_gt: Int
  lineIndex_gte: Int
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  rule: String
  rule_not: String
  rule_in: [String!]
  rule_not_in: [String!]
  rule_lt: String
  rule_lte: String
  rule_gt: String
  rule_gte: String
  rule_contains: String
  rule_not_contains: String
  rule_starts_with: String
  rule_not_starts_with: String
  rule_ends_with: String
  rule_not_ends_with: String
  isParsed: Boolean
  isParsed_not: Boolean
  AND: [RecipeIngredientScalarWhereInput!]
  OR: [RecipeIngredientScalarWhereInput!]
  NOT: [RecipeIngredientScalarWhereInput!]
}

type RecipeIngredientSubscriptionPayload {
  mutation: MutationType!
  node: RecipeIngredient
  updatedFields: [String!]
  previousValues: RecipeIngredientPreviousValues
}

input RecipeIngredientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecipeIngredientWhereInput
  AND: [RecipeIngredientSubscriptionWhereInput!]
  OR: [RecipeIngredientSubscriptionWhereInput!]
  NOT: [RecipeIngredientSubscriptionWhereInput!]
}

input RecipeIngredientUpdateDataInput {
  blockIndex: Int
  lineIndex: Int
  reference: String
  rule: String
  isParsed: Boolean
  parsed: ParsedSegmentUpdateManyInput
}

input RecipeIngredientUpdateInput {
  blockIndex: Int
  lineIndex: Int
  reference: String
  rule: String
  isParsed: Boolean
  parsed: ParsedSegmentUpdateManyInput
}

input RecipeIngredientUpdateManyDataInput {
  blockIndex: Int
  lineIndex: Int
  reference: String
  rule: String
  isParsed: Boolean
}

input RecipeIngredientUpdateManyInput {
  create: [RecipeIngredientCreateInput!]
  update: [RecipeIngredientUpdateWithWhereUniqueNestedInput!]
  upsert: [RecipeIngredientUpsertWithWhereUniqueNestedInput!]
  delete: [RecipeIngredientWhereUniqueInput!]
  connect: [RecipeIngredientWhereUniqueInput!]
  set: [RecipeIngredientWhereUniqueInput!]
  disconnect: [RecipeIngredientWhereUniqueInput!]
  deleteMany: [RecipeIngredientScalarWhereInput!]
  updateMany: [RecipeIngredientUpdateManyWithWhereNestedInput!]
}

input RecipeIngredientUpdateManyMutationInput {
  blockIndex: Int
  lineIndex: Int
  reference: String
  rule: String
  isParsed: Boolean
}

input RecipeIngredientUpdateManyWithWhereNestedInput {
  where: RecipeIngredientScalarWhereInput!
  data: RecipeIngredientUpdateManyDataInput!
}

input RecipeIngredientUpdateWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput!
  data: RecipeIngredientUpdateDataInput!
}

input RecipeIngredientUpsertWithWhereUniqueNestedInput {
  where: RecipeIngredientWhereUniqueInput!
  update: RecipeIngredientUpdateDataInput!
  create: RecipeIngredientCreateInput!
}

input RecipeIngredientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blockIndex: Int
  blockIndex_not: Int
  blockIndex_in: [Int!]
  blockIndex_not_in: [Int!]
  blockIndex_lt: Int
  blockIndex_lte: Int
  blockIndex_gt: Int
  blockIndex_gte: Int
  lineIndex: Int
  lineIndex_not: Int
  lineIndex_in: [Int!]
  lineIndex_not_in: [Int!]
  lineIndex_lt: Int
  lineIndex_lte: Int
  lineIndex_gt: Int
  lineIndex_gte: Int
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  rule: String
  rule_not: String
  rule_in: [String!]
  rule_not_in: [String!]
  rule_lt: String
  rule_lte: String
  rule_gt: String
  rule_gte: String
  rule_contains: String
  rule_not_contains: String
  rule_starts_with: String
  rule_not_starts_with: String
  rule_ends_with: String
  rule_not_ends_with: String
  isParsed: Boolean
  isParsed_not: Boolean
  parsed_every: ParsedSegmentWhereInput
  parsed_some: ParsedSegmentWhereInput
  parsed_none: ParsedSegmentWhereInput
  AND: [RecipeIngredientWhereInput!]
  OR: [RecipeIngredientWhereInput!]
  NOT: [RecipeIngredientWhereInput!]
}

input RecipeIngredientWhereUniqueInput {
  id: ID
}

type RecipeInstruction {
  id: ID!
  blockIndex: Int!
  reference: String!
}

type RecipeInstructionConnection {
  pageInfo: PageInfo!
  edges: [RecipeInstructionEdge]!
  aggregate: AggregateRecipeInstruction!
}

input RecipeInstructionCreateInput {
  id: ID
  blockIndex: Int!
  reference: String!
}

input RecipeInstructionCreateManyInput {
  create: [RecipeInstructionCreateInput!]
  connect: [RecipeInstructionWhereUniqueInput!]
}

type RecipeInstructionEdge {
  node: RecipeInstruction!
  cursor: String!
}

enum RecipeInstructionOrderByInput {
  id_ASC
  id_DESC
  blockIndex_ASC
  blockIndex_DESC
  reference_ASC
  reference_DESC
}

type RecipeInstructionPreviousValues {
  id: ID!
  blockIndex: Int!
  reference: String!
}

input RecipeInstructionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blockIndex: Int
  blockIndex_not: Int
  blockIndex_in: [Int!]
  blockIndex_not_in: [Int!]
  blockIndex_lt: Int
  blockIndex_lte: Int
  blockIndex_gt: Int
  blockIndex_gte: Int
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  AND: [RecipeInstructionScalarWhereInput!]
  OR: [RecipeInstructionScalarWhereInput!]
  NOT: [RecipeInstructionScalarWhereInput!]
}

type RecipeInstructionSubscriptionPayload {
  mutation: MutationType!
  node: RecipeInstruction
  updatedFields: [String!]
  previousValues: RecipeInstructionPreviousValues
}

input RecipeInstructionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecipeInstructionWhereInput
  AND: [RecipeInstructionSubscriptionWhereInput!]
  OR: [RecipeInstructionSubscriptionWhereInput!]
  NOT: [RecipeInstructionSubscriptionWhereInput!]
}

input RecipeInstructionUpdateDataInput {
  blockIndex: Int
  reference: String
}

input RecipeInstructionUpdateInput {
  blockIndex: Int
  reference: String
}

input RecipeInstructionUpdateManyDataInput {
  blockIndex: Int
  reference: String
}

input RecipeInstructionUpdateManyInput {
  create: [RecipeInstructionCreateInput!]
  update: [RecipeInstructionUpdateWithWhereUniqueNestedInput!]
  upsert: [RecipeInstructionUpsertWithWhereUniqueNestedInput!]
  delete: [RecipeInstructionWhereUniqueInput!]
  connect: [RecipeInstructionWhereUniqueInput!]
  set: [RecipeInstructionWhereUniqueInput!]
  disconnect: [RecipeInstructionWhereUniqueInput!]
  deleteMany: [RecipeInstructionScalarWhereInput!]
  updateMany: [RecipeInstructionUpdateManyWithWhereNestedInput!]
}

input RecipeInstructionUpdateManyMutationInput {
  blockIndex: Int
  reference: String
}

input RecipeInstructionUpdateManyWithWhereNestedInput {
  where: RecipeInstructionScalarWhereInput!
  data: RecipeInstructionUpdateManyDataInput!
}

input RecipeInstructionUpdateWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput!
  data: RecipeInstructionUpdateDataInput!
}

input RecipeInstructionUpsertWithWhereUniqueNestedInput {
  where: RecipeInstructionWhereUniqueInput!
  update: RecipeInstructionUpdateDataInput!
  create: RecipeInstructionCreateInput!
}

input RecipeInstructionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blockIndex: Int
  blockIndex_not: Int
  blockIndex_in: [Int!]
  blockIndex_not_in: [Int!]
  blockIndex_lt: Int
  blockIndex_lte: Int
  blockIndex_gt: Int
  blockIndex_gte: Int
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  AND: [RecipeInstructionWhereInput!]
  OR: [RecipeInstructionWhereInput!]
  NOT: [RecipeInstructionWhereInput!]
}

input RecipeInstructionWhereUniqueInput {
  id: ID
}

enum RecipeOrderByInput {
  id_ASC
  id_DESC
  evernoteGUID_ASC
  evernoteGUID_DESC
  title_ASC
  title_DESC
  source_ASC
  source_DESC
  image_ASC
  image_DESC
}

type RecipePreviousValues {
  id: ID!
  evernoteGUID: String
  title: String!
  source: String
  image: String
}

type RecipeSubscriptionPayload {
  mutation: MutationType!
  node: Recipe
  updatedFields: [String!]
  previousValues: RecipePreviousValues
}

input RecipeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RecipeWhereInput
  AND: [RecipeSubscriptionWhereInput!]
  OR: [RecipeSubscriptionWhereInput!]
  NOT: [RecipeSubscriptionWhereInput!]
}

input RecipeUpdateInput {
  evernoteGUID: String
  title: String
  source: String
  categories: CategoryUpdateManyInput
  tags: TagUpdateManyInput
  image: String
  ingredients: RecipeIngredientUpdateManyInput
  instructions: RecipeInstructionUpdateManyInput
}

input RecipeUpdateManyMutationInput {
  evernoteGUID: String
  title: String
  source: String
  image: String
}

input RecipeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  evernoteGUID: String
  evernoteGUID_not: String
  evernoteGUID_in: [String!]
  evernoteGUID_not_in: [String!]
  evernoteGUID_lt: String
  evernoteGUID_lte: String
  evernoteGUID_gt: String
  evernoteGUID_gte: String
  evernoteGUID_contains: String
  evernoteGUID_not_contains: String
  evernoteGUID_starts_with: String
  evernoteGUID_not_starts_with: String
  evernoteGUID_ends_with: String
  evernoteGUID_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  ingredients_every: RecipeIngredientWhereInput
  ingredients_some: RecipeIngredientWhereInput
  ingredients_none: RecipeIngredientWhereInput
  instructions_every: RecipeInstructionWhereInput
  instructions_some: RecipeInstructionWhereInput
  instructions_none: RecipeInstructionWhereInput
  AND: [RecipeWhereInput!]
  OR: [RecipeWhereInput!]
  NOT: [RecipeWhereInput!]
}

input RecipeWhereUniqueInput {
  id: ID
}

type Subscription {
  alternateName(where: AlternateNameSubscriptionWhereInput): AlternateNameSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  ingredient(where: IngredientSubscriptionWhereInput): IngredientSubscriptionPayload
  ingredientAggregate(where: IngredientAggregateSubscriptionWhereInput): IngredientAggregateSubscriptionPayload
  parsedSegment(where: ParsedSegmentSubscriptionWhereInput): ParsedSegmentSubscriptionPayload
  properties(where: PropertiesSubscriptionWhereInput): PropertiesSubscriptionPayload
  recipe(where: RecipeSubscriptionWhereInput): RecipeSubscriptionPayload
  recipeAggregate(where: RecipeAggregateSubscriptionWhereInput): RecipeAggregateSubscriptionPayload
  recipeIngredient(where: RecipeIngredientSubscriptionWhereInput): RecipeIngredientSubscriptionPayload
  recipeInstruction(where: RecipeInstructionSubscriptionWhereInput): RecipeInstructionSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
}

type Tag {
  id: ID!
  evernoteGUID: String
  name: String!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  evernoteGUID: String
  name: String!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  evernoteGUID_ASC
  evernoteGUID_DESC
  name_ASC
  name_DESC
}

type TagPreviousValues {
  id: ID!
  evernoteGUID: String
  name: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  evernoteGUID: String
  evernoteGUID_not: String
  evernoteGUID_in: [String!]
  evernoteGUID_not_in: [String!]
  evernoteGUID_lt: String
  evernoteGUID_lte: String
  evernoteGUID_gt: String
  evernoteGUID_gte: String
  evernoteGUID_contains: String
  evernoteGUID_not_contains: String
  evernoteGUID_starts_with: String
  evernoteGUID_not_starts_with: String
  evernoteGUID_ends_with: String
  evernoteGUID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  evernoteGUID: String
  name: String
}

input TagUpdateInput {
  evernoteGUID: String
  name: String
}

input TagUpdateManyDataInput {
  evernoteGUID: String
  name: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  evernoteGUID: String
  name: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  evernoteGUID: String
  evernoteGUID_not: String
  evernoteGUID_in: [String!]
  evernoteGUID_not_in: [String!]
  evernoteGUID_lt: String
  evernoteGUID_lte: String
  evernoteGUID_gt: String
  evernoteGUID_gte: String
  evernoteGUID_contains: String
  evernoteGUID_not_contains: String
  evernoteGUID_starts_with: String
  evernoteGUID_not_starts_with: String
  evernoteGUID_ends_with: String
  evernoteGUID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
  name: String
}
